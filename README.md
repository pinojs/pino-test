# pino-test

Provides a set of utilities for verifying logs generated by the Pino logger.

## Getting started
```sh
npm install pino-test --save-dev
```

```js
import { test } from 'node:test'
import pino from 'pino'
import pinoTest from 'pino-test'

test('pino should log a info message', async () => {
  const stream = pinoTest.sink()
  const logger = pino(stream)

  logger.info('hello world')

  const expected = { msg: 'hello world', level: 30 }
  await pinoTest.once(stream, expected)
})

// with a own assert function
function is (received, expected, msg) {
  if (received.msg !== expected.msg) {
    throw new Error(`expected msg ${expected.msg} doesn't match the received one ${received.msg}`)
  }
}

test('pino should log a info message using a own assert function', async () => {
  const stream = pinoTest.sink()
  const logger = pino(stream)

  logger.info('hello world')

  const expected = { msg: 'hello world', level: 30 }
  await pinoTest.once(stream, expected, is)
})
```

## API

* [sink()](#sink)
* [once()](#once)
* [consecutive()](#consecutive)
* [waitFor()](#waitfor)

<a id="sink"></a>
### `pinoTest.sink({ destroyOnError = false, emitErrorEvent = false }) => Transform`
Create a Pino destination stream to easily inspect the logs processed by Pino.

```js
import pino from 'pino'
import pinoTest from 'pino-test'

const stream = pinoTest.sink()
const logger = pino(stream)

logger.info('hello world')

stream.once('data', (data) => {
  console.log(chunk.msg) // 'hello world'
  console.log(chunk.level) // 30
})
```
Destroy the stream on error
```js
import pino from 'pino'
import pinoTest from 'pino-test'

const stream = pinoTest.sink({ destroyOnError: true })
stream.write('helloworld')
stream.end()

stream.once('close', () => {
  console.log('close event') // "close event"
})
```
Destroy and send error event on error
```js
import pino from 'pino'
import pinoTest from 'pino-test'

const stream = pinoTest.sink({ destroyOnError = false, emitErrorEvent = false })
stream.write('helloworld')
stream.end()

stream.on('error', (err) => {
  console.log(err) // Unexpected token h in JSON at position 0
})

stream.on('close', () => {
  console.log('close event') // "close event"
})
```
Send error event on error
```js
import pino from 'pino'
import pinoTest from 'pino-test'

const stream = pinoTest.sink({ emitErrorEvent = false })
stream.write('helloworld')
stream.end()

stream.on('error', (err) => {
  console.log(err) // Unexpected token h in JSON at position 0
})
```
<a id="once"></a>
### `once(stream, expectedOrCallback, is) => Promise<void>`
Assert that a single log is expected.
The function internally
- assert log message `time` is less than or equal to the current time
- assert log message `pid` matches the current process id
- assert log message `hostname` matches the current hostname
- uses the default `deepStrictEqual` assert function of the `node:assert` module.

```js
import pino from 'pino'
import pinoTest from 'pino-test'

const stream = pinoTest.sink()
const logger = pino(stream)

logger.info('hello world')

const expected = { msg: 'hello world', level: 30 }
await pinoTest.once(stream, expected) // doesn't throw a diff error
await pinoTest.once(stream, { msg: 'bye world', level: 30 }) // throw a diff error

// OR logging an object
logger.info({ hello: 'world', hi: 'world' })
await pinoTest.once(stream, { hello: 'world', hi: 'world', level: 30 }) // doesn't throw a diff error
await pinoTest.once(stream, { hello: 'world', level: 30 }) // throw a diff error

// OR using a custom assert function
function is (received, expected, msg) {
  if (received.msg !== expected.msg) {
    throw new Error(`expected msg ${expected.msg} doesn't match the received one ${received.msg}`)
  }
}

await pinoTest.once(stream, expected, is) // doesn't throw an error
await pinoTest.once(stream, { msg: 'bye world', level: 30 }, is) // throw an error

// OR using a custom callback
await pinoTest.once(stream, (received) => {
  assert.strictEqual(received.msg, 'hello world')
})
```
<a id="consecutive"></a>
### `consecutive(stream, expectedOrCallbacks, is) => Promise<void>`
Assert that consecutive logs are expected.
The function internally
- assert log message `time` is less than or equal to the current time
- assert log message `pid` matches the current process id
- assert log message `hostname` matches the current hostname
- uses the default `deepStrictEqual` assert function of the `node:assert` module.

```js
import pino from 'pino'
import pinoTest from 'pino-test'

const stream = pinoTest.sink()
const logger = pino(stream)

logger.info('hello world')
logger.info('hi world')

const expected = [
  { msg: 'hello world', level: 30 },
  { msg: 'hi world', level: 30 }
]

await pinoTest.consecutive(stream, expected) // doesn't throw a diff error
await pinoTest.consecutive(stream, [{ msg: 'bye world', level: 30 }]) // throw a diff error

// OR logging an object
logger.info({ hello: 'world' })
logger.info({ hi: 'world' })
await pinoTest.consecutive(stream, [
  { hello: 'world', level: 30 },
  { hi: 'world', level: 30 }
])

// OR using a custom assert function
function is (received, expected, msg) {
  if (received.msg !== expected.msg) {
    throw new Error(`expected msg ${expected.msg} doesn't match the received one ${received.msg}`)
  }
}

await pinoTest.consecutive(stream, expected, is) // doesn't throw an error
await pinoTest.consecutive(stream, [{ msg: 'bye world', level: 30 }], is) // throw an error

// OR using a custom callback
await pinoTest.consecutive(stream, [
  { msg: 'hello world', level: 30 },
  (received) => {
    assert.strictEqual(received.msg, 'hi world')
  }
])
```

<a id="waitfor"></a>
### `waitFor(stream, expectedOrCallbacks, assertOrOptions, options) => Promise<void>`
Assert a specific log is expected while ignoring other logs, with support for timeouts and message limits.
The function internally
- assert log message `time` is less than or equal to the current time
- assert log message `pid` matches the current process id
- assert log message `hostname` matches the current hostname
- uses the default `deepStrictEqual` assert function of the `node:assert` module

#### Parameters
- `stream`: The Pino destination stream to monitor
- `expectedOrCallbacks`: Expected log object or callback function
- `assertOrOptions`: (optional) Either a custom assert function or options object
- `options`: (optional) Additional options when using a custom assert function

#### Options
- `maxMessages`: (default: 100) Maximum number of messages to process before failing
- `timeout`: (default: 1000) Time in milliseconds to wait before failing
- `debug`: (default: false) Enable debug logging of received messages

```js
import pino from 'pino'
import pinoTest from 'pino-test'

const stream = pinoTest.sink()
const logger = pino(stream)

// Basic usage with default options
logger.debug('setup')
logger.info('server started')
logger.error('error occurred')
await pinoTest.waitFor(stream, { msg: 'server started', level: 30 })

// With custom maxMessages limit
await pinoTest.waitFor(stream, expected, { maxMessages: 5 })

// With all options
await pinoTest.waitFor(stream, expected, {
  maxMessages: 5,
  timeout: 2000,
  debug: true
})

// With custom assert function
function is(received, expected) {
  if (received.msg !== expected.msg) {
    throw new Error(`expected msg ${expected.msg} doesn't match the received one ${received.msg}`)
  }
}
await pinoTest.waitFor(stream, expected, is)

// With custom assert and options
await pinoTest.waitFor(stream, expected, is, {
  maxMessages: 5,
  timeout: 2_000
})

// With callback function
await pinoTest.waitFor(stream, (received) => {
  assert.strictEqual(received.msg, 'server started')
})

// With callback function and options
await pinoTest.waitFor(stream, (received) => {
  assert.strictEqual(received.msg, 'server started')
}, { maxMessages: 5 })

// Error handling
try {
  await pinoTest.waitFor(stream, expected, { timeout: 100 })
} catch (err) {
  console.log(err.message) // "Timeout on waitFor: expected message"
}

try {
  await pinoTest.waitFor(stream, expected, { maxMessages: 2 })
} catch (err) {
  console.log(err.message) // "Max message count reached on waitFor: expected message"
}
```
